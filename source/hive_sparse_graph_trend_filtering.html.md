---
title: Sparse Graph Trend Filtering (HIVE)

toc_footers:
  - <a href='https://github.com/gunrock/gunrock'>Gunrock&colon; GPU Graph Analytics</a>
  - Gunrock &copy; 2018 The Regents of the University of California.

search: true

full_length: true
---

# Sparse Graph Trend Filtering

Given each vertex on the graph has its own weight, the sparse graph trend filtering tries to learn a new weight that is (1) sparse (mostly of the vertices have weights 0), (2) close to the original weight in l2 norm, and (3) close to its neighbors' weight(s) in l1 norm. This algorithm is usually used in main trend filtering (denoising). The loss function is `0.5 * sum(y' - y)^2 + lambda1 * sum|yi' - yj'| + lambda2 * sum|yi'|`, where y
is the input weights for each vertex and y' is the new weights for each vertex. For example, an image (grid graph) with noisy pixels can be applied with this algorithm to get a new image without the noisy pixels, which are "smoothed" out by its neighbors.
<https://arxiv.org/abs/1410.7690>

## Summary of Results

(fill this in)

## Summary of Gunrock Implementation

The graph is preprocessed by two files. The first file contains the original vertices' weights and the second file contains the directed graph connectivity without weights (edge pairs only). These two files and a parameter(lambda1) of the directed graph edge weights are the input to the preprocessing file. Two extra nodes, source and sink, are added to the original graph as well. This results in a graph, where the edges excluding the ones connecting to source or sink have edge-weights lambda1, while the edges connecting to source or sink have edge-weights as in the `vertices' weights` file.

The Gunrock implementation of this application has two parts. The first part is the maxflow algorithm. We choose a push-relabel maxflow formulation, which is well-suited to parallelize on GPU with Gunrock. The output of this maxflow algorithm is (1) a residual graph where each edge weight is computed as `capacity - edge_flow`, and (2) a Boolean array indicating if each vertex is reachable from the source, once we have the residual graph. Given the graph has only one connected component, in the maxflow/min-cut problem, a graph will be segmented into two sub-graphs, where one of the sub-graph is only reachable from the source, and the other sub-graph is only reachable from the sink. The reachability of a vertex from the source is defined as that it is possible to find a path between the source and the vertex.  

The second part is a renormalization of the residual graph and clustering based on reachability of the vertex. The renormalization is a process where (1) averages of the new weights of vertices that are grouped together as communities are computed, and (2) the new weights are then subtracted by their own community averages. After the renormalization is done, this renormalized residual graph is passed into the maxflow again. Several iterations between maxflow and renormalization are needed before the new weights of different communities converge because vertices can be reassigned to different communities. In each of the GTF iteration, two non-overlapped sub-graphs will be generated by maxflow/min-cut, and thus the big communities in the last GTF iteration will be splitted into small communities. The vertices in a specific community will have the same new weights assigned to them.    

The outputs will be the normalized values assigned to each vertex.

Lastly, these values will be passed into a soft-threshold function with `lambda2` to achieve the sparse representation by dropping the small absolute values. More specifically, the new weight will be subtracted by `lambda2` if the new weight is positive and larger than `lambda2`, or added by `lambda2` if the new weight is negative and smaller than -`lambda2`. If the new weight is in between -`lambda2` to `lambda2`, then the new weights will be 0.

Pseudocode for the core GTF algorithm is as follows (simplified version):

```
Load the graph and normalize edge weights

for iteration till converge:

    # Maxflow
    Call maxflow data preprocessing
    Call maxflow and return boolean reachability array and residual graph


    # Reset available community
    for comm till num_comms
        community_weights[comm] = 0
        community_sizes  [comm] = 0
        next_communities [comm] = 0

    # Accumulate the weights and count the number of vertices belong to the communities
    for vertex in the graph
        if vertex accessible from the source
            comm = next_communities[curr_communities[vertex]];
                if comm == 0
                    update comm
            community_sizes[comm] += 1
            community_weights[comm] += weight between source and this current vertex
        else
            community_weights[comm] -= weight between vertex and this sink
            community_sizes [comm] ++;

    # Normalize community
    for comm in num_communities
        if comm is active and next_communities[comm] is not zero
            community_weights[comm] /= community_sizes[comm]
            community_accus [comm] += community_weights[comm]



    # Update the residual graph
    for vertex in the graph
        comm = curr_communities[vertex]
        if vertex is reachable from the source
            edge[source->vertex] -= community_weights[comm]
            if edge[source->vertex] < 0
                swap(-edge[source->vertex], edge[vertex->sink])
        else
            edge[vertex->sink] += community_weights[comm]
            if edge[vertex->sink] < 0
            swap(edge[source->vertex], -edge[vertex->sink])
```


## How To Run This Application on DARPA's DGX-1

### Prereqs/input

CUDA should have been installed; `$PATH` and `$LD_LIBRARY_PATH` should have been
set correctly to use CUDA. The current Gunrock configuration assumes boost
(1.58.0 or 1.59.0) and metis are installed; if not, changes need to be made in
the Makefiles. DARPA's DGX-1 has both installed when the tests are performed.

```shell
git clone --recursive https://github.com/gunrock/gunrock/
cd gunrock
git checkout dev-refactor
git submodule init
git submodule update
mkdir build
cd build
cmake ..
cd ../tests/gtf
make
```
At this point, there should be an executable `gtf_main_<CUDA version>_x86_64`
in `tests/gtf/bin`.

The testing is done with Gunrock using `dev-refactor` branch at commit `2699252`
(Oct. 18, 2018), using CUDA 9.1 with NVIDIA driver 390.30.

### HIVE Data Preparation

Prepare the data; skip this step if you are just running the sample dataset.

Refer to `parse_args()` in taxi_tsv_file_preprocessing.py for dataset preprocessing options.
Set the lambda1 (see equation above) in generate_graph.py for Gunrock.

```shell
cd gunrock/tests/gtf/_data

export TOKEN= # get this Authentication TOKEN from https://api-token.hiveprogram.com/#!/user
mkdir -p _data
wget --header "Authorization:$TOKEN" \
  https://hiveprogram.com/data/_v0/sparse_fused_lasso/taxi/taxi-small.tar.gz
tar -xzvf taxi-small.tar.gz && rm -r taxi-small.tar.gz
mv taxi-small _data/

wget --header "Authorization:$TOKEN" \
  https://hiveprogram.com/data/_v0/sparse_fused_lasso/taxi/taxi-1M.tar.gz
tar -xzvf taxi-1M.tar.gz && rm -r taxi-1M.tar.gz
mv taxi-1M _data/

python taxi_tsv_file_preprocessing.py
python generate_graph.py
```

Then three files are generated. The files `e` and `n` are for benchmarks, and `std_added.mtx` is for Gunrock input.

### Running the application
```
--lambda2 is the sparsity regularization constant
```
Sample command line with argument.
```shell
./bin/test_gtf_10.0_x86_64 market ./_data/std_added.mtx --lambda2 3
```

### Output

The code will output two files in the current directory. One is called `output_pr.txt` (for CPU reference) and the other is called `output_pr_GPU.txt` (for GPU GTF with push-relabel backend).
Each vertex's new weight will be stored in each line of the two files. These outputs could be further processed into the resulting heatmap.
The printout after running `gtf_main_<CUDA version>_x86_64` includes the timing of the application.

Sample output in the `.txt` is
```
0
0
0
0
0
0
-11.375
-0.307292
0
```

Sample important printf on the screen is
```
______CPU reference algorithm______                                                                                                                                  [9/1944]
offset is 58522 num edges 76366
!!!!!!!!!! avg is -0.876037
Iteration 0
Iteration 1
Iteration 2
Iteration 3
Iteration 4
Iteration 5
Iteration 6
Iteration 7
Iteration 8
Iteration 9
Iteration 10
Iteration 11
-----------------------------------
Elapsed: 5500.730991 ms
in side that weird function1
offset in GPU preprocess is 58522 num edges 76366
avg in GPU preprocess is -0.876037
Using advance mode LB
Using filter mode CULL
Using advance mode LB
Using filter mode CULL
offset is 58522 num edges 76366
h_community_accus is -0.876037
______GPU SFL algorithm____
enact calling successfully!!!!!!!!!!!
-----------------------------------
Run 0, elapsed: 3341.358185 ms, #iterations = 12
transfering to host!!!: 8924
[gtf] finished.
 avg. elapsed: 3341.358185 ms
 iterations: 0
 min. elapsed: 3341.358185 ms
 max. elapsed: 3341.358185 ms
 load time: 138.952 ms
 preprocess time: 342.184000 ms
 postprocess time: 0.258923 ms
 total time: 3845.412016 ms

```

## Performance and Analysis

We measure the runtime and loss function `0.5 * sum(y' - y)^2 + lambda1 * sum|yi' - yj'| + lambda2 * sum|yi'|`, where `y` is the old weight per vertex and `y'` is the new weight per vertex.

### Implementation limitations

The time is mostly spent on maxflow computation. Each iteration of the GTF calls a maxflow. The time spent on maxflow vs. the rest of the GTF post-processing is around 20:1 (8922 vertices and 20349 edges) per iteration. The maxflow implementation has room for further optimization; we expect to have shorter runtime on maxflow in the future. We only implement serial GTF renormalization(second part) for correctness purposes. If the graph is larger, we expect the ratio between maxflow(first part) and GTF renormalization(second part) will be lower, because the runtime of the renormalization is serial.

### Comparison against existing implementations
Graphtv is an official implementation of graph trend filtering algorithm with parametric maxflow backend. It is CPU serial implementation. The Gunrock GPU runtime is measured between the application enactor and it is an output of the application.

| DataSet | time starts | time ends | #E | #V | graphtv runtime | Gunrock GPU runtime |
|-------------- |---------------------|--------------------|----------|----------|------| ---|
| NY Taxi-small | 2011-06-26 12:00:00 |2011-06-26 14:00:00 | 20349 | 8922 | 0.11s |  *3.59s |
| NY Taxi-small | 2011-06-26 00:00:00 |2011-06-27 00:00:00 | 293259 | 107064 | 8.71s | |
| NY Taxi-1M | 2011-06-19 00:00:00 |2011-06-27 00:00:00 | 588211 | 213360 | 103.62s |  |

| DataSet | time starts | time ends | #E | #V | graphtv loss | Gunrock GPU loss |
|-------------- |---------------------|--------------------|----------|----------|-------------------| -------------------|
| NY Taxi-small | 2011-06-26 12:00:00 |2011-06-26 14:00:00 | 20349 | 8922 | 132789.32 | *132789.32 |
| NY Taxi-small | 2011-06-26 00:00:00 |2011-06-27 00:00:00 | 293259 | 107064 | |                     |
| NY Taxi-1M | 2011-06-19 00:00:00 |2011-06-27 00:00:00 | 588211 | 213360 | |                     |

`*`The GPU implementation of maxflow still has bug that leads to different results per run. We only report the best result we can achieve with the current version of maxflow. Since this current version of maxflow is able to achieve the same loss as the Graphtv, we presume that the results, both the runtime and loss, should be similar or even better with a bug-free maxflow.

### Performance limitations

e.g., random memory access? talks about MF more?


## Next Steps

### Alternate approaches(Done)

> If you had an infinite amount of time, is there another way (algorithm/approach) we should consider to implement this?

For CPU, the parametric maxflow algorithm works well, but it is not parallelizable to GPU. The push-relabel algorithm we have on Gunrock's maxflow should be the best implementation among the parallelizable algorithms on GPU.

### Gunrock implications

> What did we learn about Gunrock? What is hard to use, or slow? What potential Gunrock features would have been helpful in implementing this workflow?

GTF is the first algorithm that stacks previous applications. Some data pre-processing that is common to execute in the CPU requires better designs of the APIs which will facilitate new applications. For example, gtf_enactor needs to call mf_problem.reset. Since the current maxflow code does not have any preprocessing of the graph on GPU, GTF has to transfer the data back and forth between CPU and GPU and unnecessary arrays to store the Maxflow input arrays are needed in GTF. It would have been much better if maxflow has more preprocessing on GPU.

Moreover, a unit test framework is super necessary. If we don't do unit tests per few functions, it is hard to track the problems and discover simple, avoidable but missing test cases, such as comparison between two double values in GTF. A mockito test framework is best for reference. http://www.vogella.com/tutorials/Mockito/article.html

### Notes on multi-GPU parallelization

> What will be the challenges in parallelizing this to multiple GPUs on the same node?
>
> Can the dataset be effectively divided across multiple GPUs, or must it be replicated?

### Notes on dynamic graphs

(Only if appropriate)

> Does this workload have a dynamic-graph component? If so, what are the implications of that? How would your implementation change? What support would Gunrock need to add?

### Notes on larger datasets

> What if the dataset was larger than can fit into GPU memory or the aggregate GPU memory of multiple GPUs on a node? What implications would that have on performance? What support would Gunrock need to add?

### Notes on other pieces of this workload

> Briefly: What are the important other (non-graph) pieces of this workload? Any thoughts on how we might implement them / what existing approaches/libraries might implement them?

### Research opportunities

> "{what you've done with respect to this workflow / what you could do} that you think has research value and could lead to a paper". We should write those down now when they're fresh in our minds. This is less for DARPA and more for us, for our discussion. I know not every one of these workflows will lead to a research advance. But there are research advances in implementing the workflow AND implementing interesting parts of the workflow (e.g., sparse data structures) AND other things we could use pieces of the workflow to solve (e.g., auction algorithm)

Prof.Sharpnack indicates that this implementation could be generalized to multi-graph fused lasso. The idea is to set multiple edge values for the edges connecting to source/sink, while keeping the graph topology and edges values(lambda1) for the edges in the original graph(excluding source and sink) the same.  
